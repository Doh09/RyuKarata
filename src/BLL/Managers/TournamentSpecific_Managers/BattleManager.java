/*
 * This class handles the battles of a single tournament.
 * The class has a TreeMap with the battles.
 * CRUD Functionality is implemented.
 * The TreeMap with all the battles can be retrieved as an ArrayList
 * for iteration purposes.
 */
package BLL.Managers.TournamentSpecific_Managers;

import BE.Fighter;
import BE.Tournaments.Battles.Battle;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 *
 * @author Simon, Martin, Alex, Casper
 */
public class BattleManager {

    /**
     * Variables
     */
    private Map<Integer, Battle> battles = new TreeMap(); //A map of all battles held by this manager.
    private final int tournamentId; //The id of the tournament this manager belongs to.

    /**
     * Constructor, is purposely not made Singleton, as the program potentially
     * runs more than one tournament at a time.
     *
     * @param tournamentId
     */
    public BattleManager(int tournamentId) {
        this.tournamentId = tournamentId;
    }

    /**
     * @return a map with the battles of the tournament.
     */
    public Map<Integer, Battle> getMapOfBattles() {
        return battles;
    }

    /**
     * Replace all battles in this battlemanagers Map, with the given Map.
     *
     * @param battles
     */
    public void setBattles(TreeMap<Integer, Battle> battles) {
        this.battles = Collections.synchronizedMap(battles);
    }

    /**
     * @param i, the index of the battle, is the battles id.
     * @return a battle based on its index key.
     */
    public Battle getBattleByIndex(int i) {
        return battles.get(i);
    }

    /**
     * Add a battle to the managers map. If the ID of the battle is already in
     * the map, it is overwritten.
     *
     * @param b
     */
    public void addOrUpdateBattleToMap(Battle b) {
        battles.put(b.getId(), b);
    }

    /**
     * Remove a battle from the managers map, based on its key/ID.
     *
     * @param i
     */
    public void removeBattleFromMap(int i) {
        battles.remove(i);
    }

    /**
     * Converts the synchronized map to a list and returns it. The list returned
     * may not be synchronized, unless you make it so.
     *
     * @return
     */
    public ArrayList<Battle> getAllAsArrayList() {
        ArrayList<Battle> list = new ArrayList<>(battles.values());
        return list;
    }

    /**
     * Returns a complete list of all the battles a fighter is participating in,
     * has participated in or is set to participate in.
     *
     * @param f
     * @return list of battles
     */
    public ArrayList<Battle> getBattleFighterList(Fighter f) {
        ArrayList<Battle> temp = new ArrayList<>();

        for (Battle b : getAllAsArrayList()) {
            if (b.battleContainsFighter(f)) {
                temp.add(b);
            }
        }

        return temp;
    }

    /**
     * @return the id of the tournament this manager belongs to.
     */
    public int getTournamentId() {
        return tournamentId;
    }

    /**
     * Create a battle and add 2 fighters to it. The battles id will be
     * generated by the manager and will be unique. After creation the battle
     * will be added to the managers map.
     *
     * @param red
     * @param blue
     * @return the battle created.
     */
    public Battle createBattle(Fighter red, Fighter blue) {
        int id = 0;

        for (Battle ba : getAllAsArrayList()) {
            if (ba.getId() >= id) {
                id = ba.getId() + 1;
            }
        }

        Battle b = new Battle(id, red, blue);
        addOrUpdateBattleToMap(b);
        return b;
    }

    /**
     * Create a battle. The battles id will be generated by the manager and will
     * be unique. After creation the battle will be added to the managers map.
     *
     * @return the battle created.
     */
    public Battle createBattle() {
        int id = 0;

        for (Battle ba : getAllAsArrayList()) {
            if (ba.getId() >= id) {
                id = ba.getId() + 1;
            }
        }

        Battle b = new Battle(id);
        addOrUpdateBattleToMap(b);
        return b;
    }

    /**
     * Method used to, after a fighter has been selected winner, add him to the
     * next battle in line, use null as parameter to remove the winner from the
     * next battle.
     *
     * @param currentBattle
     */
    public void addWinnerIfNextBattle(Battle currentBattle) {
        if (currentBattle != null) {
            Battle nxtBttle = currentBattle.getNextBattle();
            Fighter currBtlWinner = currentBattle.getWinner();
            if (nxtBttle != null) //If the battle is not null (meaning not the final one) and a winner has been selected.
            {
                addWinnerNextBattle(nxtBttle, currBtlWinner, currentBattle);
                //Purposely did not use recursive, to avoid errors and to avoid user accidentally deleting a lot of battle outcomes.
            }
        }
    }

    /**
     * Adds the fighter to the battle nxtBttle if nxtBattle has currentBattle as
     * one of its 2 previous battles.
     *
     * @param nxtBttle
     * @param currBtlWinner
     * @param currentBattle
     */
    private void addWinnerNextBattle(Battle nxtBttle, Fighter currBtlWinner, Battle currentBattle) {
        if (currentBattle.getId() == nxtBttle.getPreviousBattle1().getId()) {
            nxtBttle.setFighter1Red(currBtlWinner);
            nxtBttle.setRedWarnings(new ArrayList<>());
        } else if (currentBattle.getId() == nxtBttle.getPreviousBattle2().getId()) {
            nxtBttle.setFighter2Blue(currBtlWinner);
            nxtBttle.setBlueWarnings(new ArrayList<>());
        }
    }

}
